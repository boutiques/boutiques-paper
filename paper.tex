\documentclass{article}

%%%% Packages %%%%

\usepackage{minted} % Used for JSON highlighting
\usepackage{pdfcomment} % Used for notes and todos
\usepackage[margin=1in]{geometry} % Increases margins
\usepackage{lscape} % Used to put a section in landscape mode
\usepackage[table]{xcolor} % Color definitions
\usepackage{algorithm} % Algorithm float
\usepackage{algpseudocode} % Algorithmic environment

%%%% Commands %%%%

\newcommand{\note}[2]{\pdfmargincomment[color=yellow,author=#1,open=true]{#2}}
\newcommand{\todo}[2]{\pdfmargincomment[color=red,author=#1,open=true]{#2}}
\algrenewcommand{\algorithmiccomment}[1]{\# \textit{#1}} % so that comments in algorithms are preprended by '#' instead of a small right arrow

\title{Boutiques: a flexible framework for automated application integration in computing platforms}

\begin{document}

\author{Tristan Glatard, Tristan Aumentado-Armstrong, Natacha Beck, Pierre Bellec,\\
        Remi Bernard, Sorina Camarasu-Pop, Fr\'ed\'eric Cervenansky, Samir Das, \\
        Rafael Ferreira da Silva,John Flavin, Pascal Girard, Krzysztof J. Gorgolewski, \\
        Charles G. Guttmann, Nathaniel Kofalt, Pierre-Olivier Quirion, Pierre Rioux,\\
        Gunnar Schaeffer, Marc-\'Etienne Rousseau, Alan C. Evans}

\maketitle

\section{Introduction}

Why Linux. Define application. Define computing platforms. Explain the
problem and why it is difficult. Approach: start simple and enrich the
spec when new applications come. Refer to computing infrastructures
and the need for parallelization. Who are
the developers. Refer to neuroinformatics field. 

Vocabulary (check consistency across the paper):
\begin{itemize}
\item tool vs. application.
\item descriptor vs. manifest.
\item task vs. invocation.
\end{itemize}

\section{System description}

Define ``the platform'', i.e. the entity that will run applications.
\begin{itemize}
\item JSON manifest
\item Link to container
\item Invocation schema
\end{itemize}

\subsection{Command-line description}

The core component of the JSON manifest is a flexible command-line
description represented as a simple string template complying to the
syntax of the \texttt{bash} Linux shell interpreter. The command line
template may contain placeholders for input and output values, called
value keys. The value keys may be any string, and the
command line may actually encompass several commands, e.g., separated
by semicolumns, pipes (\texttt{|}) or ampersands (\texttt{\&}). Such a
flexible command-line specification is meant to facilitate the
embedding of minor operations on the command line, for instance input
decompression and output archival, avoiding the use of multiple
``shims'' to align mismatching applications in a
pipeline~\cite{hull2004treating}.

Here is an example of a typical command-line template:
\begin{verbatim}
exampleTool_1 [STRING_INPUT] [FILE_INPUT] [ENUM_INPUT] | \
                              exampleTool_2 [FLAG_INPUT] [NUMBER_INPUT] >> [LOG].txt
\end{verbatim}
The template contains six value keys for input and output
values. When the application is executed, such keys will be replaced
by values and file names according to the user input. Flags will also
be added wherever appropriate, with customizable separators. No
particular syntax is imposed for the value keys, they just have
to be unique.  Note the use of the pipe (\texttt{|}) operator to chain
tools, and of the \texttt{>>} operator to redirect the standard output
to a file.

\subsection{Input description}

\paragraph{General properties.} Inputs must have a name, a unique
identifier and a type. They may be optional, have a description, a
value key, a flag and flag separator, and a default
value. Inputs may also be ordered lists; in this case, value
keys are substituted by the space-separated list of input values.

\paragraph{Types.} Inputs may be of type \texttt{String},
\texttt{Number}, \texttt{Flag} or \texttt{File}. \texttt{File} may
also represent a directory. Types can be restricted to a specific set
of values (\texttt{String} and \texttt{Number} only), to a specific
range (\texttt{Number} only), to integers or to booleans (\texttt{Number}
only).

\paragraph{Groups and dependencies.} Groups of inputs may be defined
from a identifier, name and list of input identifiers. Groups may be
used to improve the presentation in a graphical user interface and to
specify the following constraints among inputs: (1)
\texttt{mutually-exclusive}: only one input in the group may have a
value; (2) \texttt{one-is-required}: at least one input in the group
must have a value. Dependencies among inputs may also be defined
regardless of a particular group: an input may (1) require a list of
inputs (2) disable a list of inputs.

Listing~\ref{listing:input-example} shows the definition of an input
in the command line exemplified above. According to this definition
and assuming that the input value entered by the user is 0.3, the
string \texttt{[NUMBER\_INPUT]} will be replaced by \texttt{-n=0.3} on
the command line at execution time.
\begin{listing}
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{js}
{
    "id" : "num_input",
    "name" : "A number input",
    "type" : "Number",
    "value-key" : "[NUMBER_INPUT]",
    "optional" : true,
    "command-line-flag" : "-n",
    "command-line-separator" : "=",
    "minimum" : 0,
    "maximum" : 1,
    "exclusive-minimum" : true,
    "exclusive-maximum" : false
  }
\end{minted}
\caption{Input example.} 
\label{listing:input-example}
\end{listing}

\subsection{Output description}

Application outputs are the files or directories that need to be
transferred and delivered to the user once the execution is
complete. Although it may not be required to distinguish inputs from
outputs to build the application command line, this information is
needed by computing platforms to identify the files that must be
saved after the execution.

In Boutiques, output files are defined from a unique identifier, a
name and a path template that specifies the file or directory
name. Path templates may include input value keys in case
output files are named after the input values. Input values may be
stripped from specific strings, e.g., file extensions before being
substituted in the path template. Output files may also have a
description, a command-line flag, a flag separator, and a value
key in case they appear on the command line. They may be optional in
case the file is not always produced by the application, for instance
when it is produced only when a particular flag is activated. They
may also be (un-ordered) lists; in this case, the path template must
contain a wildcard (\texttt{*}) matching any string of characters
and defining the pattern used to match the
output files in the list.

Listing~\ref{listing:output-example} shows the definition of an output
file in the command line exemplified before. According to this
definition and assuming that the string input value entered by the
user is "foo.csv", the string \texttt{[LOG]} will be
replaced by \texttt{log-foo} on the command line at execution time.

\begin{listing}
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{js}

{
    "id" : "logfile",
    "name" : "Log file",
    "description" : "The output log file from the example tool",
    "path-template" : "log-[STRING_INPUT]",
    "value-key" : "[LOG]",
    "path-template-stripped-extensions" : [".txt", ".csv"],
    "optional" : false
}
\end{minted}
\caption{Output file example} 
\label{listing:output-example}
\end{listing}

\subsection{Configuration files}

A large number of applications rely on configuration files rather than
command-line options to define their input and output
parameters. Indeed, as the number of parameters increases, command
lines rapidly become long and cumbersome whereas configuration files
allow for better structure and documentation.

Configuration files may be complex though, and specified in any
language.  As it does not seem reasonable to adopt a particular
template for configuration files, the Boutiques specification allows
application developers to specify their own template, referring to
input and output value keys. Configuration files are specific types of
output files that have a
 file template defined. As output files, 
they must have a path template that defines
how they must be named and where they must be written. They may also
have a value key and a flag in case they need to be passed on the
command line. 


Listing~\ref{listing:configuration-file-example} shows an example.
\begin{listing}
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{js}
               {
                   "id": "config_file",
                   "name": "Configuration file",
                   "type": "Configuration File",
                   "value-key": "[CONFIG_FILE]",
                   "path-template": "config.txt",
                   "file-template": [
                   "# This input is hard-coded",
                   "stringInput=foo",
                   "fileInput=[FILE-INPUT]",
                   "# And here is the result",
                   "fileOutput=[OUTPUT-FILE]",
                   ""
                   ]
                 }
\end{minted}
\caption{Configuration file example. The file template is defined as
  an array of strings to allow for multi-line strings in JSON.}
\label{listing:configuration-file-example}
\end{listing}

\subsection{Invocation schema}
\label{sec:invocation-schema}

Rigorous input validation is an important motivation for
Boutiques. The obvious solution in our context is to rely on an
application-specific JSON schema, called ``invocation schema'', to
specify the correct input values that an application
accepts. Platforms could rely on the invocation schema to validate
inputs automatically using any JSON validator, without having to
develop specific code.

Invocation schemas, however, are complex JSON objects. Basically, they
must represent the properties described above in a formal way,
including dependencies between
inputs. Listing~\ref{listing:invocation-schema-example} shows an
example of how dependencies between mutually exclusive parameters are
defined in the invocation schema.

The invocation schema also has a \texttt{task-dependencies} array that
specifies that the new invocation to start only when all the
invocations in this array have completed. This property is used in the
parallelization model described hereafter.

\begin{listing}
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{js}
"dependencies" : {
      "num_input" : {
         "properties" : {
            "str_input" : {
               "not" : {}
            }
         }
      },
      "str_input" : {
         "properties" : {
            "num_input" : {
               "not" : {}
            }
         }
      }
   }
\end{minted}
\caption{Excerpt from invocation schema showing dependencies between
  two mutually exclusive parameters \texttt{num\_input} and
  \texttt{str\_input}.}
\label{listing:invocation-schema-example}
\end{listing}


It does not seem realistic to assume that developers will easily write
correct JSON schemas for their applications. Instead, invocation
schemas should be generated automatically using a core Boutiques
tool. Accordingly, invocation schema is an optional property of the
Boutiques manifest, that platforms or developers may generate using
the appropriate tool.

\subsection{Parallelization support}
\label{sec:parallelization}
Boutiques support parallelism by allowing applications to submit new
tasks through the following protocol:
\begin{enumerate}
\item Applications write a JSON object complying to the invocation
  schema in the directory where there were launched.
\item The platform reads the JSON object, creates the corresponding
  task, and writes back the task id in the same directory.
% The platform could also support status requests.
\end{enumerate}
Several invocations can be submitted at once, possibly using the
\texttt{task-dependencies} array to specify dependencies among
them. This mechanism is implemented in the Boutiques schema using a
single property, \texttt{can-submit-tasks}.

Although very simple, this model allows wrapping complete
workflows. Workflows are wrapped as any other application, and they
can be executed using any engine such as Nipype, PSOM and others,
provided that such engines are installed in the container image
referred in the application manifest. 

The adopted ``task encapsulation'' model is very simple but it
allows for a scalable and reliable execution of workflows expressed in
a variety of languages, as detailed in ~\cite{glatard2016fgcs}.

\subsection{Containers}

The implementation of the application is defined in a container image
in the Docker, Singularity or rootfs format. We intentionally support
multiple container formats as we anticipate that they will be used for
different purposes. For instance, Docker is well suited for
application developers and users who want to use applications on their
local workstation. It is very well documented, maintained and it has a
rich ecosystem of tools to help build and run containers on most
platforms, including Windows, MacOS and Linux. Singularity is more
suited for users and platforms that need to run applications on shared
computing clusters. Bridges exist among these containers formats to
convert container images across frameworks. For instance, a platform
dedicated to high-performance computing may accept manifests referring
to Docker containers to facilitate application integration by
developers, and internally convert container images to Singularity to
run applications efficiently on clusters.

Container images are defined from their URL (Singularity and rootfs)
or name in a Docker index. Container images may specify a working
directory where the application has to be run. A hash may also be
reported to accurately identify container images and detect updates.

Containers are adopted because they allow for an automated and
lightweight integration of application implementations in
platforms. They are extremely useful to improve the reproducibility of
analyses as variations in the software environment may have an
important impact on the computed results. They also have limitations,
in particular they do not specify the hardware architecture required
to execute an application, which can be an issue in some cases.

Containers are not mandatory though. If an application manifest does
not contain any reference to a container, the platform will assume
that the application is pre-installed on the execution infrastructure. 

\subsection{Custom properties}

Custom properties may be added to the Boutiques specification without
restriction. They may be useful to implement platform-specific
features but they should be used with care to avoid making tools
dependent on a particular platform. The following custom properties
have been used so far:
\begin{itemize}
\item \texttt{cbrain:inherits-from-class}: a string that defines the
  Ruby class that should be used as parent class for the tool in
  CBRAIN. Used to define a progress bar for PSOM tools in CBRAIN.
\item \texttt{vip:miccai-challenger-email} and
  \texttt{vip:miccai-challenge-team-name}: strings helping VIP
  categorize tools for the 2016 MICCAI challenges ``MSSEG'' and
  ``PETSEG''.
\end{itemize}

\subsection{Command-line construction}

At runtime, a value is assigned to all the mandatory and some of the
optional inputs. Inputs of type "String" may contain any string,
inputs of type "Number" must contain a string representing a number,
inputs of type "File" must contain a string representing a file path
(absolute or relative to the execution directory) and inputs of type
"Flag" must contain a boolean. When input is a list, the value
contains the concatenation of all strings in the list.

Algorithm~\ref{algo:command-line} shows how the application command
line is constructed from the application manifest and values entered
by the user. It substitutes all the value keys in the command line,
output path templates and configuration files, and writes the
configuration files.

\begin{algorithm}[htb]
\caption{Command-line construction}
\label{algo:command-line}
\begin{algorithmic}
  \State \Comment{Substitute input value keys in output path templates, configuration files and command line.}
  \For{\texttt{input} in \texttt{inputs}}
  \If{\texttt{input} has a \texttt{value-key}}
  \For{\texttt{output} in \texttt{outputs}}
  \State \texttt{stripped\_value} = \texttt{input\_value}
  \If{\texttt{input} type is \texttt{File}}
  \State In \texttt{stripped\_value}, remove  all elements in \texttt{path-template-stripped-extensions}.
  \EndIf
  \State In \texttt{path-template}, replace all occurrences of \texttt{value-key} by \texttt{stripped\_value}.
  \If{\texttt{output} has a \texttt{file-template}}
  \State In any line of \texttt{file-template}, replace all occurrences of \texttt{value-key} by \texttt{stripped\_value}.
  \EndIf
  \EndFor
  \State Prepend \texttt{command-line-flag} and \texttt{command-line-flag-separator} to \texttt{input\_value}.
  \State In \texttt{command-line}, replace all occurrences of \texttt{value-key} by \texttt{input\_value}.
  \EndIf
  \EndFor

  \State \Comment{Substitute output value keys in configuration files and command line.}
  \For{\texttt{output} in \texttt{outputs}}
  \If{\texttt{output} has a \texttt{value-key}}
  \For{\texttt{output} in \texttt{outputs}}
  \If{\texttt{output} has a \texttt{file-template}}
  \State In any line of \texttt{file-template}, replace all occurrences of \texttt{value-key} by \texttt{path-template}.
  \State \Comment{Input \texttt{value-key} have been substituted in \texttt{path-template} previously.}
  \EndIf
  \EndFor
  \State Prepend \texttt{command-line-flag} and \texttt{command-line-flag-separator} to \texttt{path-template}.
  \State In \texttt{command-line}, replace all occurrences of \texttt{value-key} by \texttt{path-template}.
  \EndIf
  \EndFor

  \State \Comment{Write all configuration files.}
  \For{\texttt{output} in \texttt{outputs}}
  \If{\texttt{output} has a \texttt{file-template}}
  \State Write \texttt{file-template} in \texttt{path-template}
  \State \Comment{Value keys have been substituted in \texttt{file-template} previously.}
  \EndIf
  \EndFor

\end{algorithmic}
\end{algorithm}

\section{Implementation and Evaluation}

\subsection{Core tools} 

The Boutiques validator checks conformance of JSON manifests to the
Boutiques schema using a basic JSON validator. It also performs an
additional set of checks that cannot be easily implemented in JSON
schema: value keys are unique among inputs, input and output
identifiers are unique, input and output value keys are all
included in the command line, value keys are not contained
within each other (which would puzzle substitution), output path
templates are unique (to avoid results to overwrite each other),
inputs of type Flag have a command-line flag, are optional and are not
lists, number and list constraints are sensible (e.g. min is lower
than max), the default value of enum types is part of the enum, an
input cannot both require and disable another input, required inputs
cannot require or disable other parameters, group member identifiers
must correspond to existing inputs and cannot appear in different
groups, mutually exclusive groups cannot have members requiring other
members, and that one-is-required groups should never have required
members. The Boutiques validator is meant for application developers.

The local executor can generate and execute command line from a
Boutiques manifest and a set of input values represented in a CSV or
JSON file complying with the invocation schema. It runs the
command in a container provided that the required framework
(e.g. Docker) is already installed. It can also generate hypothetical
command lines from random values, for debugging purposes. The local
executor can be used by application users, to run tools locally, or by
platforms, to generate command lines to be run on the execution
infrastructure.

The invocation schema generator creates an invocation schema (see
Section~\ref{sec:invocation-schema}) from a Boutiques manifest and
validates data against it. It can be used by platform administrators
to add invocation schemas to existing manifests, and by platforms to
validate input data. Validation is done using a basic JSON
validator.

\subsection{Repository}

\subsection{Ported applications}

% cbrain-plugins-neuro

The Pipeline System for Octave and Matlab
(PSOM)~\cite{bellec2012pipeline} has been integrated in CBRAIN using
Boutiques. More precisely, a manifest has been written for a Niak
pre-processing pipeline and PSOM workers. The integration uses the
parallelization mechanism described in
Section~\ref{sec:parallelization} so that even the tasks processing a
given subject can be parallelized. As shown in~\cite{GLAT-16}, this
allows CBRAIN to leverage the efficient agent model used in PSOM. The
integration required some work in PSOM to facilitate its invocation as
a non-interactive command-line application. The resulting CBRAIN
plugin is available at
\url{https://github.com/SIMEXP/cbrain-plugins-psom}. It could in
principle be used in other platforms that support the parallelization
property, although this has not been tested.

% SPM?
% BIDS Apps

Table~\ref{table:applications} summarizes the applications described
with Boutiques and the main features used.
\begin{landscape}
  \begin{table}
  \rowcolors{2}{gray!25}{white}
  \begin{tabular}{l|ccc|ccccccc|cc}
    Application               &\multicolumn{3}{c|}{Containers} & \multicolumn{7}{c|}{Input/Output properties}                         & \multicolumn{2}{c}{Other properties}  \\
                              &Docker              & Singularity & Rootfs  & Dependencies      &Groups             & Lists             & Optional          &Default            & Enum              & Min/max           & Config. file & Env vars     \\
    \hline
    Niak pre-processing       &\cellcolor{gray!75} &            &         &                   &\cellcolor{gray!75}&                   &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&              &\cellcolor{gray!75}\\
    ICA AROMA                 &\cellcolor{gray!75} &            &         &\cellcolor{gray!75}&\cellcolor{gray!75}&                   &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&              &\\
    FSL tools &&&&&&&&&&&&\\
    \multicolumn{1}{r|}{anat} &                    &            &         &\cellcolor{gray!75}&\cellcolor{gray!75}&                   &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&              &\\
    \multicolumn{1}{r|}{bet}  &                    &            &         &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&                   &                   &\cellcolor{gray!75}&              &\\      
    \multicolumn{1}{r|}{fast} &                    &            &         &\cellcolor{gray!75}&                   &                   &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&              &\\
    \multicolumn{1}{r|}{first}&                    &            &         &                   &                   &\cellcolor{gray!75}&\cellcolor{gray!75}&\cellcolor{gray!75}&                   &                   &              &\\
    FSL Nipype interfaces     \\
    HCP PreFreesurfer         &\cellcolor{gray!75} &            &         &                   &                   &                   &                   &                   &                   &                   &              &\\
    MSSEG MICCAI pipelines    \\
    PETSEG MICCAI pipelines   \\
\end{tabular}
\caption{Applications available in Boutiques with manifest features used.}
\label{table:applications}
  \end{table}
  \end{landscape}

\subsection{Platforms}

\paragraph{CBRAIN}

New list mechanism.

\paragraph{Pegasus}

\paragraph{SPINE}

\paragraph{VIP}


\section{Related work}

Boutiques intentionally does not support the definition of complete
workflows from individual applications. Indeed, we believe that
workflow engines are specific tools that need complex languages to
implement the particular functions that they target. Efforts to
specify common workflow languages include the Common Workflow Language
(CWL)~\cite{cwl} and the Interoperable Workflow Intermediate
Representation (IWIR)~\cite{plankensteiner2011iwir}.


% CWL
The Common Workflow Language (CWL) is the closest related work to
Boutiques, in the sense that it also allows the description of command
lines executed in containers. According to Github, the CWL project
started 6 months before Boutiques. The main conceptual differences
between CWL and Boutiques are the following:
\begin{itemize}
\item CWL has a workflow language, Boutiques does not. CWL also has a
  command line tool description language, but its specification is
  influenced by the fact that command line tools are included in a
  specific workflow languages. In Boutiques, the only available
  workflow construct is sub-tasking (``a task may submit other
  tasks''). This is intentional as we envisage that Boutiques tools
  may be composed through any type of workflow engine and language. For instance, this leads to have multiple output types in CWL.
\item CWL specifies command lines formally whereas in Boutiques they
  are assembled from simple string templates. In short, a command line
  in CWL is specified by an executable and an ordered list of
  parameters. While this representation has the advantage of being
  more formal, for instance the executable can be identified
  automatically, it also removes flexibility by imposing that a tool
  only runs a single command. On the contrary, Boutiques allows any
  type of bash operators to be combined on the command line. This
  level of flexibility is important and greatly reduces the ``shim
  syndrome''. Boutiques' template approach allows for configuration files. 
\item CWL is validated using SALAD, which makes the ecosystem slightly
  more complex. For instance, CWL has ``import'' and ``include''
  directives. Boutiques is validated using plain JSON schema. \todo{ontology layer}.
\item In CWL, the applications need to be instrumented as follows, which is not the case in Boutiques:
\begin{itemize}
\item Applications must write in specific directories.
\item Applications must produce a JSON object describing the output structure.
\end{itemize}
\end{itemize}

\todo{Tristan}{Update from comparison summary on Google doc}

\section{Discussion}

% How to build modular container images for workflows.

\section{Conclusion}

\section{Acknowledgments}

Amazon grant.

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
